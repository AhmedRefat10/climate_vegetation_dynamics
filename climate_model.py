# -*- coding: utf-8 -*-
"""climate_model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GSwmwDu9OeyJ9ZkClZpYGBdUqIrVx8w3
"""

import pandas as pd

"""Rainfall data; CHIRPS"""

df_rainfall = pd.read_csv('/content/Nairobi_CHIRPS_Rainfall.csv')

# pd.set_option('display.max_rows', None)     #to view all the rows of this dataset
# df_rainfall

df_rainfall.shape

#We drop rows before 18/12/2000
df_rainfall_temp = df_rainfall.iloc[7291:].copy()
df_rainfall_new = df_rainfall_temp.reset_index(drop=True)

df_rainfall_new.tail()

df_rainfall_new.shape

"""---

Wind pattern data: NetCDF
"""

df_wind = pd.read_csv('/content/reanalysis-era5-single-levels-timeseries-sfciwwo50_z.csv')
df_wind.shape

# df_wind.tail(50)

df_wind_temp = df_wind.iloc[534408:].copy()
df_wind_new_temp = df_wind_temp.reset_index(drop=True)

df_wind_new_temp.tail()

df_wind_new = df_wind_new_temp.iloc[:-3744].copy()

df_wind_new.head()

df_wind_new.shape

"""---

Vegetation dada(NVDI): AppEEARS
"""

df_vegetation = pd.read_csv('/content/MODIS-Terra-Vegetation-Indices-16-Day-L3-Global-25-MOD13Q1-061-results.csv')

df_vegetation.shape

# pd.set_option('display.max_rows', None)
df_vegetation.tail()

df_vegetation.columns

df_vegetation.shape

"""Downloading the processed data (abhi tak jitna kiya)"""

from google.colab import files
output_filename = 'rainfall_data.csv'

# Save the DataFrame to a CSV file in the Colab environment
df_rainfall_new.to_csv(output_filename, index=False)
print(f"DataFrame saved as '{output_filename}' in Colab.")

try:
    # --- Corrected: Pass the filename string to files.download() ---
    files.download(output_filename)
    print(f"'{output_filename}' download initiated to your local machine.")
except Exception as e:
    print(f"An error occurred during download: {e}")

"""---

Merging the datasets
"""

import pandas as pd

# Step 1: Convert date columns to datetime
df_rainfall_new['date'] = pd.to_datetime(df_rainfall_new['date'])
df_vegetation['date'] = pd.to_datetime(df_vegetation['Date'])  # assuming original column is 'Date'
df_wind_new['date'] = pd.to_datetime(df_wind_new['valid_time'])  # assuming original column is 'valid_time'

# Step 2: Resample wind data (hourly ‚Üí daily average)
wind_daily = df_wind_new.groupby(df_wind_new['date'].dt.date).agg({
    'u10': 'mean',
    'v10': 'mean'
}).reset_index()
wind_daily['date'] = pd.to_datetime(wind_daily['date'])

# Step 3: Select relevant columns
rainfall_clean = df_rainfall_new[['date', 'rainfall_mm']]
vegetation_clean = df_vegetation[['date', 'MOD13Q1_061__250m_16_days_NDVI']]
wind_clean = wind_daily[['date', 'u10', 'v10']]

# Step 4: Merge all datasets on 'date'
merged_df = pd.merge(rainfall_clean, vegetation_clean, on='date', how='outer')
merged_df = pd.merge(merged_df, wind_clean, on='date', how='outer')

# Step 5: Sort and rename columns
merged_df = merged_df.sort_values(by='date').reset_index(drop=True)
merged_df = merged_df.rename(columns={
    'MOD13Q1_061__250m_16_days_NDVI': 'NDVI (Vegetation)',
    'rainfall_mm': 'Rainfall (mm)',
    'u10': 'Wind u10',
    'v10': 'Wind v10'
})

# Preview the final merged dataframe
merged_df.head(10)
merged_df.shape

# pd.set_option('display.max_rows', None)
# merged_df

"""Time-Based Linear Interpolation - to fill in the missing values in vegetation"""

# Step 1: Set 'date' as index (required for time interpolation)
merged_df.set_index('date', inplace=True)

# Step 2: Interpolate missing NDVI values based on time
merged_df['NDVI (Vegetation)'] = merged_df['NDVI (Vegetation)'].interpolate(method='time')

# Step 3: Reset index to bring 'date' back as a column
merged_df.reset_index(inplace=True)

# Optional: Check if any missing NDVI values remain
print("Missing NDVI values after interpolation:", merged_df['NDVI (Vegetation)'].isna().sum())

"""--- Handle Missing Data in Other Variables ---"""

# Re-set datetime index to use time-based interpolation
merged_df.set_index('date', inplace=True)

# Interpolate missing values in rainfall and wind
merged_df['Rainfall (mm)'] = merged_df['Rainfall (mm)'].interpolate(method='time')
merged_df['Wind u10'] = merged_df['Wind u10'].interpolate(method='time')
merged_df['Wind v10'] = merged_df['Wind v10'].interpolate(method='time')

# Reset index again after interpolation
merged_df.reset_index(inplace=True)

merged_df.head()

df_final = merged_df.copy()

"""---

Lets work on the model now :)

Predicting NDVI 16 days ahead

Didn't work very well -  lets try XGBoost
"""

!pip install xgboost

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

def plot_forecast(actual, predicted, title, ylabel, figsize=(14, 5), save_as=None):
    plt.figure(figsize=figsize)
    sns.lineplot(x=range(len(actual)), y=actual, label='Actual', linewidth=2)
    sns.lineplot(x=range(len(predicted)), y=predicted, label='Predicted', linestyle='--')
    plt.title(title, fontsize=16)
    plt.xlabel('Time Steps')
    plt.ylabel(ylabel)
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    if save_as:
        plt.savefig(save_as)
    plt.show()

from xgboost import XGBRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score

# ------------------------------------
# Step 1: Feature Engineering
# ------------------------------------
# Calculate wind speed
merged_df['Wind Speed'] = np.sqrt(merged_df['Wind u10']**2 + merged_df['Wind v10']**2)

# Lag features
merged_df['NDVI_lag'] = merged_df['NDVI (Vegetation)'].shift(1)
merged_df['Rainfall_lag'] = merged_df['Rainfall (mm)'].shift(1)
merged_df['WindSpeed_lag'] = merged_df['Wind Speed'].shift(1)

# ------------------------------------
# Step 2: Target Variable (NDVI 16 days ahead)
# ------------------------------------
merged_df['NDVI_t+16'] = merged_df['NDVI (Vegetation)'].shift(-16)

# ------------------------------------
# Step 3: Drop missing rows
# ------------------------------------
model_df = merged_df.dropna(subset=['NDVI_lag', 'Rainfall_lag', 'WindSpeed_lag', 'NDVI_t+16'])

# ------------------------------------
# Step 4: Prepare features and target
# ------------------------------------
features = ['NDVI_lag', 'Rainfall_lag', 'WindSpeed_lag']
target = 'NDVI_t+16'

X = model_df[features]
y = model_df[target]

# Train/test split (time-based: no shuffling)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

# ------------------------------------
# Step 5: Train XGBoost Regressor
# ------------------------------------
xgb_model = XGBRegressor(n_estimators=100, learning_rate=0.1, max_depth=4, random_state=42)
xgb_model.fit(X_train, y_train)

# ------------------------------------
# Step 6: Predict and evaluate
# ------------------------------------
y_pred = xgb_model.predict(X_test)

# rmse = mean_squared_error(y_test, y_pred, squared=False)
mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse) # Use np.sqrt from numpy

r2 = r2_score(y_test, y_pred)

print("RMSE:", rmse)
print("R¬≤ Score:", r2)

# ------------------------------------
# Step 7: Plot Actual vs Predicted
# ------------------------------------
plt.figure(figsize=(12, 5))
plt.plot(y_test.values, label='Actual NDVI (t+16)', linewidth=2)
plt.plot(y_pred, label='Predicted NDVI (t+16)', linestyle='--')
plt.title('NDVI Forecasting with XGBoost (16 days ahead)')
plt.xlabel('Time Steps')
plt.ylabel('NDVI')
plt.legend()
plt.grid(True)
plt.show()

"""Improving the model"""

# Add More Lag Features
merged_df['NDVI_lag2'] = merged_df['NDVI (Vegetation)'].shift(2)
merged_df['Rainfall_lag2'] = merged_df['Rainfall (mm)'].shift(2)
merged_df['WindSpeed_lag2'] = merged_df['Wind Speed'].shift(2)

# Add Rolling Averages (Smooth Trends)
merged_df['NDVI_rolling7'] = merged_df['NDVI (Vegetation)'].rolling(window=7).mean()
merged_df['Rainfall_rolling7'] = merged_df['Rainfall (mm)'].rolling(window=7).mean()
merged_df['Wind_rolling7'] = merged_df['Wind Speed'].rolling(window=7).mean()

# Add Seasonality Info (Month/Day)
merged_df['Month'] = merged_df['date'].dt.month
merged_df['DayOfYear'] = merged_df['date'].dt.dayofyear

# Drop rows with missing values after feature engineering
model_df = merged_df.dropna()

# Define your feature columns
features = [
    'NDVI_lag', 'NDVI_lag2', 'NDVI_rolling7',
    'Rainfall_lag', 'Rainfall_lag2', 'Rainfall_rolling7',
    'WindSpeed_lag', 'WindSpeed_lag2', 'Wind_rolling7',
    'Month', 'DayOfYear'
]
target = 'NDVI_t+16'

X = model_df[features]
y = model_df[target]


# Train/Test Split (time-aware)
from sklearn.model_selection import train_test_split

# No shuffling since it's time series
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)



# Train XGBoost with new features
from xgboost import XGBRegressor
from sklearn.metrics import mean_squared_error, r2_score

# Train model
xgb_model = XGBRegressor(n_estimators=200, learning_rate=0.05, max_depth=5, random_state=42)
xgb_model.fit(X_train, y_train)

# Predict
y_pred = xgb_model.predict(X_test)

# Evaluation
mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)
r2 = r2_score(y_test, y_pred)

print("RMSE:", rmse)
print("R¬≤ Score:", r2)

# Hyperparameter Tuning for XGBoost
from sklearn.model_selection import RandomizedSearchCV
from xgboost import XGBRegressor
import numpy as np

# Define parameter grid
param_grid = {
    'n_estimators': [100, 200, 300],
    'max_depth': [3, 4, 5, 6],
    'learning_rate': [0.01, 0.05, 0.1],
    'subsample': [0.6, 0.8, 1.0],
    'colsample_bytree': [0.6, 0.8, 1.0]
}

xgb = XGBRegressor(random_state=42)

random_search = RandomizedSearchCV(
    estimator=xgb,
    param_distributions=param_grid,
    n_iter=20,
    cv=3,
    verbose=1,
    scoring='neg_root_mean_squared_error',
    random_state=42,
    n_jobs=-1
)

random_search.fit(X_train, y_train)

# Best model
best_xgb = random_search.best_estimator_

# Evaluate
y_pred = best_xgb.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
rmse = np.sqrt(mse)
r2 = r2_score(y_test, y_pred)

print("Tuned XGBoost RMSE:", rmse)
print("Tuned XGBoost R¬≤ Score:", r2)
print("Best Params:", random_search.best_params_)

"""Multi-Step NDVI Forecasting"""

# 1. Create Multi-step Targets
merged_df['NDVI_t+1'] = merged_df['NDVI (Vegetation)'].shift(-1)
merged_df['NDVI_t+7'] = merged_df['NDVI (Vegetation)'].shift(-7)
merged_df['NDVI_t+16'] = merged_df['NDVI (Vegetation)'].shift(-16)
merged_df['NDVI_t+30'] = merged_df['NDVI (Vegetation)'].shift(-30)

# 2. Drop NaNs and Select Features
targets = ['NDVI_t+1', 'NDVI_t+7', 'NDVI_t+16', 'NDVI_t+30']

model_df = merged_df.dropna(subset=features + targets)

X = model_df[features]
Y = model_df[targets]

# Train/Test Split
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, shuffle=False)



# 3. Train Separate Models for Each Step
models = {}
preds = {}
for step in targets:
    model = XGBRegressor(**random_search.best_params_, random_state=42)
    model.fit(X_train, Y_train[step])
    pred = model.predict(X_test)

    # mse = mean_squared_error(y_test, y_pred)
    mse = mean_squared_error(Y_test[step], pred)
    rmse = np.sqrt(mse)
    r2 = r2_score(Y_test[step], pred)

    print(f"\nüìà Forecast {step}:")
    print(f"   RMSE: {rmse:.4f}")
    print(f"   R¬≤:   {r2:.4f}")

    models[step] = model
    preds[step] = pred


# 4. (Optional) Plot Forecasts
import matplotlib.pyplot as plt


for step in targets:
    plot_forecast(Y_test[step].values, preds[step], f'NDVI Forecast: {step}', 'NDVI')

"""---

**Monitoring Wind Patterns**

Wind Speed and Wind Direction
"""

# Calculate Wind Speed if not already present
if 'Wind Speed' not in df_final.columns:
    df_final['Wind Speed'] = np.sqrt(df_final['Wind u10']**2 + df_final['Wind v10']**2)

# Calculate Wind Direction (in degrees from North)
df_final['Wind Direction (degrees)'] = np.degrees(np.arctan2(
    df_final['Wind v10'], df_final['Wind u10']
))
df_final['Wind Direction (degrees)'] = (df_final['Wind Direction (degrees)'] + 360) % 360

"""Detect Anomalies or Sudden Shifts"""

# Rolling average for wind speed (7-day window)
df_final['Wind Speed Rolling Mean'] = df_final['Wind Speed'].rolling(window=7).mean()

# Wind speed anomaly
df_final['Wind Speed Anomaly'] = df_final['Wind Speed'] - df_final['Wind Speed Rolling Mean']

# Flag high wind alerts (top 5% wind speeds)
threshold = df_final['Wind Speed'].quantile(0.95)
df_final['High Wind Alert'] = df_final['Wind Speed'] > threshold

"""(Optional) Detect Wind Regime Shifts"""

# Categorize wind direction into cardinal sectors
def wind_sector(degrees):
    if degrees < 45 or degrees >= 315:
        return 'N'
    elif degrees < 135:
        return 'E'
    elif degrees < 225:
        return 'S'
    else:
        return 'W'

df_final['Wind Sector'] = df_final['Wind Direction (degrees)'].apply(wind_sector)

"""**Multi-step wind speed & direction forecast using XGBoost**

1. Feature Engineering
"""

import pandas as pd
import numpy as np

# Ensure date is datetime
df_final['date'] = pd.to_datetime(df_final['date'])

# Set index for rolling
df_final = df_final.sort_values('date').reset_index(drop=True)

# --- Feature Engineering ---
df_final['WindSpeed_lag1'] = df_final['Wind Speed'].shift(1)
df_final['WindSpeed_lag2'] = df_final['Wind Speed'].shift(2)
df_final['WindSpeed_rolling7'] = df_final['Wind Speed'].rolling(window=7).mean()

# Wind direction as a circular variable (sin/cos transformation)
df_final['WindDir_sin'] = np.sin(np.radians(df_final['Wind Direction (degrees)']))
df_final['WindDir_cos'] = np.cos(np.radians(df_final['Wind Direction (degrees)']))

# Time-based features
df_final['Month'] = df_final['date'].dt.month
df_final['DayOfYear'] = df_final['date'].dt.dayofyear

"""2. Create Multi-step Targets"""

# Targets: Wind speed and direction ahead
df_final['WindSpeed_t+1'] = df_final['Wind Speed'].shift(-1)
df_final['WindSpeed_t+3'] = df_final['Wind Speed'].shift(-3)
df_final['WindSpeed_t+7'] = df_final['Wind Speed'].shift(-7)

df_final['WindDir_t+1'] = df_final['Wind Direction (degrees)'].shift(-1)
df_final['WindDir_t+3'] = df_final['Wind Direction (degrees)'].shift(-3)
df_final['WindDir_t+7'] = df_final['Wind Direction (degrees)'].shift(-7)

"""3. Prepare Data"""

# Define features and targets
features = [
    'WindSpeed_lag1', 'WindSpeed_lag2', 'WindSpeed_rolling7',
    'WindDir_sin', 'WindDir_cos', 'Month', 'DayOfYear'
]

targets = [
    'WindSpeed_t+1', 'WindSpeed_t+3', 'WindSpeed_t+7',
    'WindDir_t+1', 'WindDir_t+3', 'WindDir_t+7'
]

# Drop rows with missing data
df_model = df_final.dropna(subset=features + targets)

X = df_model[features]
Y = df_model[targets]

# Train/Test Split
from sklearn.model_selection import train_test_split

# X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, shuffle=False)
X_train_wind, X_test_wind, Y_train_wind, Y_test_wind = train_test_split(X, Y, test_size=0.2, shuffle=False)

"""4. Train XGBoost Models"""

from xgboost import XGBRegressor
from sklearn.metrics import mean_squared_error, r2_score

# Store models and predictions
models = {}
predictions = {}

# Train separate model for each target
for target in targets:
    model = XGBRegressor(n_estimators=200, learning_rate=0.05, max_depth=4, random_state=42)
    # model.fit(X_train, Y_train[target])
    model.fit(X_train_wind, Y_train_wind[target])

    # pred = model.predict(X_test)
    pred = model.predict(X_test_wind)
    predictions[target] = pred

    # rmse = np.sqrt(mean_squared_error(Y_test[target], pred))
    # r2 = r2_score(Y_test[target], pred)
    rmse = np.sqrt(mean_squared_error(Y_test_wind[target], pred))
    r2 = r2_score(Y_test_wind[target], pred)

    print(f"üìä Forecast for {target}")
    print(f"   RMSE: {rmse:.4f}")
    print(f"   R¬≤ Score: {r2:.4f}\n")

    models[target] = model

"""5. Plot Forecasts"""

import matplotlib.pyplot as plt

for target in wind_targets:
    target = target.strip()
    plot_forecast(Y_test_wind[target].values, predictions[target], f'{target} Forecast', 'Value')

"""---

**Adaptation Layer**
"""

# Pick the last prediction from test set
sample_ndvi_pred = y_pred[-1]  # NDVI_t+16
sample_rainfall = X_test['Rainfall_lag'].iloc[-1]
sample_wind = X_test['WindSpeed_lag'].iloc[-1]

# Adaptation decision function
def adaptation_advice(ndvi, rainfall, wind_speed):
    tips = []
    if ndvi < 0.3:
        tips.append("‚ö†Ô∏è Vegetation stress detected. Consider irrigation.")
    if rainfall < 2:
        tips.append("üíß Low rainfall. Monitor soil moisture.")
    if wind_speed > 12:
        tips.append("üå¨Ô∏è High wind alert. Delay pesticide spraying.")
    if not tips:
        tips.append("‚úÖ Conditions are stable. No immediate action needed.")
    return tips

# Run it
print("üìà Model Predictions:")
print(f"NDVI: {sample_ndvi_pred:.3f}, Rainfall: {sample_rainfall:.2f}, Wind Speed: {sample_wind:.2f}")
print("\nüß† Adaptation Advice:")
for tip in adaptation_advice(sample_ndvi_pred, sample_rainfall, sample_wind):
    print(tip)

"""**Export Visuals and Metrics**"""

import matplotlib.pyplot as plt

# Save NDVI forecasts
for step in preds:
    plt.figure(figsize=(12, 4))
    plt.plot(Y_test[step].values, label='Actual', linewidth=2)
    plt.plot(preds[step], label='Predicted', linestyle='--')
    plt.title(f'NDVI Forecast: {step}')
    plt.xlabel('Time Steps')
    plt.ylabel('NDVI')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.savefig(f'NDVI_forecast_{step}.png')  # Save each plot
    plt.close()

# Collect evaluation metrics
ndvi_metrics = []
for step in preds:
    rmse = np.sqrt(mean_squared_error(Y_test[step], preds[step]))
    r2 = r2_score(Y_test[step], preds[step])
    ndvi_metrics.append({
        "Target": step,
        "RMSE": round(rmse, 4),
        "R2 Score": round(r2, 4)
    })

# Convert to DataFrame and save
metrics_df = pd.DataFrame(ndvi_metrics)
metrics_df.to_csv("NDVI_forecast_metrics.csv", index=False)

# Save predictions and actual values
for step in preds:
    df_preds = pd.DataFrame({
        "Actual": Y_test[step].values,
        "Predicted": preds[step]
    })
    df_preds.to_csv(f"NDVI_predictions_{step}.csv", index=False)

from google.colab import files

# Download all exported files
files.download("NDVI_forecast_metrics.csv")
for step in preds:
    files.download(f"NDVI_forecast_{step}.png")
    files.download(f"NDVI_predictions_{step}.csv")

"""Export Forecast Plots (WindSpeed & Direction)"""

import os
import matplotlib.pyplot as plt

# Create export directory
export_dir = "wind_forecast_outputs"
os.makedirs(export_dir, exist_ok=True)

# Export plots for each forecast target
for target in ['WindSpeed_t+1', 'WindSpeed_t+3', 'WindSpeed_t+7',
               'WindDir_t+1', 'WindDir_t+3', 'WindDir_t+7']:
    plt.figure(figsize=(10, 4))
    # Change Y_test to Y_test_wind here
    plt.plot(Y_test_wind[target].values, label='Actual', linewidth=2)
    plt.plot(predictions[target], label='Predicted', linestyle='--')
    plt.title(f'Forecast: {target}')
    plt.xlabel('Time Steps')
    plt.ylabel('Value')
    plt.legend()
    plt.grid(True)

    filename = os.path.join(export_dir, f"{target}_forecast.png")
    plt.savefig(filename)
    plt.close()
    print(f"‚úÖ Saved: {filename}")

import pandas as pd
from sklearn.metrics import mean_squared_error, r2_score
import numpy as np

# Collect metrics
metrics = []

for target in ['WindSpeed_t+1', 'WindSpeed_t+3', 'WindSpeed_t+7',
               'WindDir_t+1', 'WindDir_t+3', 'WindDir_t+7']:
    pred = predictions[target]
    # Ensure you are using Y_test_wind for metrics as well
    rmse = np.sqrt(mean_squared_error(Y_test_wind[target], pred))
    r2 = r2_score(Y_test_wind[target], pred)
    metrics.append({'Target': target, 'RMSE': rmse, 'R¬≤': r2})

# Save to CSV
metrics_df = pd.DataFrame(metrics)
metrics_csv_path = os.path.join(export_dir, "wind_forecast_metrics.csv")
metrics_df.to_csv(metrics_csv_path, index=False)
print(f"üìÑ Metrics saved to: {metrics_csv_path}")

import pandas as pd
from sklearn.metrics import mean_squared_error, r2_score
import numpy as np

# Collect metrics
metrics = []

for target in ['WindSpeed_t+1', 'WindSpeed_t+3', 'WindSpeed_t+7',
               'WindDir_t+1', 'WindDir_t+3', 'WindDir_t+7']:
    pred = predictions[target]
    # rmse = np.sqrt(mean_squared_error(Y_test[target], pred))
    # r2 = r2_score(Y_test[target], pred)
    rmse = np.sqrt(mean_squared_error(Y_test_wind[target], pred))
    r2 = r2_score(Y_test_wind[target], pred)
    metrics.append({'Target': target, 'RMSE': rmse, 'R¬≤': r2})

# Save to CSV
metrics_df = pd.DataFrame(metrics)
metrics_csv_path = os.path.join(export_dir, "wind_forecast_metrics.csv")
metrics_df.to_csv(metrics_csv_path, index=False)
print(f"üìÑ Metrics saved to: {metrics_csv_path}")

from google.colab import files
import os

# Assuming 'export_dir' is defined and the files are saved there
export_dir = "wind_forecast_outputs"

print("\nInitiating downloads...")

# Download the metrics CSV
metrics_csv_path = os.path.join(export_dir, "wind_forecast_metrics.csv")
try:
    files.download(metrics_csv_path)
    print(f"'{metrics_csv_path}' download initiated.")
except Exception as e:
    print(f"Error downloading '{metrics_csv_path}': {e}")

# Download each forecast plot
for target in ['WindSpeed_t+1', 'WindSpeed_t+3', 'WindSpeed_t+7',
               'WindDir_t+1', 'WindDir_t+3', 'WindDir_t+7']:
    filename = os.path.join(export_dir, f"{target}_forecast.png")
    try:
        files.download(filename)
        print(f"'{filename}' download initiated.")
    except Exception as e:
        print(f"Error downloading '{filename}': {e}")

print("\nAll download commands have been issued. Check your browser's download location.")

"""

---

"""

# Save predictions with timestamps
pred_df = X_test.copy()
pred_df['Predicted_NDVI_t+16'] = y_pred
pred_df['Actual_NDVI_t+16'] = y_test.values
pred_df['Date'] = model_df['date'].iloc[-len(pred_df):].values  # Add dates

pred_df.to_csv("predicted_ndvi.csv", index=False)

from google.colab import files
files.download("predicted_ndvi.csv")

import pandas as pd
from google.colab import files

# Reuse your existing wind targets list or redefine it:
wind_targets = [
    'WindSpeed_t+1', 'WindSpeed_t+3', 'WindSpeed_t+7',
    'WindDir_t+1', 'WindDir_t+3', 'WindDir_t+7'
]

# build a dataframe with actuals and predictions
# Crucial Change: Use Y_test_wind instead of Y_test
wind_output = pd.DataFrame(index=Y_test_wind.index) # Use index from Y_test_wind

for target in wind_targets:
    # Crucial Change: Use Y_test_wind for actual values
    wind_output[f'Actual_{target}'] = Y_test_wind[target]
    wind_output[f'Predicted_{target}'] = predictions[target] # 'predictions' is a dict from previous step

# Save to CSV
wind_output.to_csv("predicted_wind.csv", index=False)

# Download in Colab
files.download("predicted_wind.csv")

"""Some extra plotting"""

import seaborn as sns

def plot_forecast(actual, predicted, title, ylabel, figsize=(14, 5), save_as=None):
    plt.figure(figsize=figsize)
    sns.lineplot(x=range(len(actual)), y=actual, label='Actual', linewidth=2)
    sns.lineplot(x=range(len(predicted)), y=predicted, label='Predicted', linestyle='--')
    plt.title(title, fontsize=16)
    plt.xlabel('Time Steps')
    plt.ylabel(ylabel)
    plt.grid(True)
    plt.legend()
    plt.tight_layout()
    if save_as:
        plt.savefig(save_as)
    plt.show()

"""Save Predictions, Plots & Metrics

NDVI
"""

# Get dates for test set
ndvi_dates = model_df['date'].iloc[-len(Y_test):].reset_index(drop=True)

# For each step, save actual + predicted + date
for step in preds:
    df_preds = pd.DataFrame({
        'Date': ndvi_dates,
        'Actual NDVI': Y_test[step].values,
        'Predicted NDVI': preds[step]
    })
    df_preds.to_csv(f"NDVI_{step}_forecast.csv", index=False)

for step in preds:
    plot_forecast(
        actual=Y_test[step].values,
        predicted=preds[step],
        title=f'NDVI Forecast: {step}',
        ylabel='NDVI',
        save_as=f"NDVI_{step}_plot.png"
    )

ndvi_metrics = []

for step in preds:
    rmse = np.sqrt(mean_squared_error(Y_test[step], preds[step]))
    r2 = r2_score(Y_test[step], preds[step])
    ndvi_metrics.append({
        'Target': step,
        'RMSE': round(rmse, 4),
        'R¬≤': round(r2, 4)
    })

# Save metrics to CSV
ndvi_metrics_df = pd.DataFrame(ndvi_metrics)
ndvi_metrics_df.to_csv("NDVI_forecast_metrics.csv", index=False)

"""Wind Pattern"""

# Get dates for wind test set
wind_dates = df_model['date'].iloc[-len(Y_test_wind):].reset_index(drop=True)

for target in wind_targets:
    df_wind = pd.DataFrame({
        'Date': wind_dates,
        'Actual': Y_test_wind[target].values,
        'Predicted': predictions[target]
    })
    df_wind.to_csv(f"Wind_{target}_forecast.csv", index=False)

for target in wind_targets:
    plot_forecast(
        actual=Y_test_wind[target].values,
        predicted=predictions[target],
        title=f'Wind Forecast: {target}',
        ylabel='Value',
        save_as=f"Wind_{target}_plot.png"
    )

wind_metrics = []

for target in wind_targets:
    rmse = np.sqrt(mean_squared_error(Y_test_wind[target], predictions[target]))
    r2 = r2_score(Y_test_wind[target], predictions[target])
    wind_metrics.append({
        'Target': target,
        'RMSE': round(rmse, 4),
        'R¬≤': round(r2, 4)
    })

# Save metrics to CSV
wind_metrics_df = pd.DataFrame(wind_metrics)
wind_metrics_df.to_csv("Wind_forecast_metrics.csv", index=False)

from google.colab import files
import glob

# Download all generated CSVs and PNGs
for file_path in glob.glob("*.csv") + glob.glob("*.png"):
    files.download(file_path)

"""

---

"""

import pandas as pd
import matplotlib.pyplot as plt
from sklearn.metrics import mean_squared_error, r2_score
import numpy as np
from google.colab import files

# 1. Export separate CSVs for each NDVI prediction step
for step in preds:
    df_step = pd.DataFrame({
        'Date': model_df['date'].iloc[-len(Y_test):].values,
        'Actual NDVI': Y_test[step].values,
        'Predicted NDVI': preds[step]
    })
    filename = f"NDVI_predictions_{step}.csv"
    df_step.to_csv(filename, index=False)
    files.download(filename)

# 2. Save and download plot for each prediction step
for step in preds:
    plt.figure(figsize=(12, 4))
    plt.plot(Y_test[step].values, label='Actual NDVI', linewidth=2)
    plt.plot(preds[step], label='Predicted NDVI', linestyle='--')
    plt.title(f'NDVI Forecast Plot: {step}')
    plt.xlabel('Time Steps')
    plt.ylabel('NDVI')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()

    plot_filename = f"NDVI_plot_{step}.png"
    plt.savefig(plot_filename)
    plt.close()
    files.download(plot_filename)

from google.colab import files
files.download("NDVI_forecast_metrics.csv")